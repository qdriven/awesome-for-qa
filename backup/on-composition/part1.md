主要结论：1、确定依赖关系结构 2、选择模块之间的边界，以及选择这些边界的原因 3、具体选择编译期和运行时的实现方案
part1 是论述依赖关系意味着什么，要如何选择依赖关系

```
低代码平台的最核心是两个部分：

- 可扩展的一体化开发框架
- 差异化扩展的方法论

后者是需要对开发者说清楚的事情。。。
```

先从问题定义开始。差异化的扩展方法论，这个问题的起源是这样的：
1、我们需要lowcode
2、lowcode不是解决方案，只是一个需求，这个需求就是用更便宜的人更快的交付。就是一个纯资本家的需求
3、要更快，无非是真的让生产效率更高，要么就是转移工作量，提前把一些活给干了。第一个问题太难了，所以lowcode基本上都选择了，限定问题域，提前把活干了。
4、这种提前把活干了可以有好几种形式，比如直接提供一个可用的app，然后你配置几个参数就可以用了。这个app可以是b端的，比如给运营提供一个可配置的发优惠券系统。也可以是c端，比如excel。
5、也可以是提供一个接近可用的app片段，比如说提供一个评论系统，你只需要配置到你的博客系统里，就可以把博客加上评论了。
6、也可以是提供一些没有直接用户价值的app片段，比如提供一个登录模块的library，一个营销活动的区块。然后你需要通过一定的编码来把这些片段编排出来。这个编排可以是可视化搭建，也可以是写文本文件的脚本，也可以是块编辑的projection editor。
7、也可以是提供生成app的生成器，比如你建了一个表，定义了一堆字段，然后增删改查界面就生成出来了。
8、以上都是提前把活干了的可选项，但是本质上都是一样的，别人先把活干了，然后你来坐享其成。
9、在归纳一下，这个就是在你的项目里引入了一个依赖，然后你把你应该干的活，推给这个依赖来做了。
10、所以问题就是，这个依赖库/service/app不完全符合我的需求怎么办?

所以我想说的就是太阳之下没有新雪，不要打着lowcode的旗号，就认为可以凭空发明新的idea出来。这个差异化扩展的问题就是经典的软件工程问题。至少从问题定义上来说，可以归纳到经典的软件工程问题上来

造成这个问题的一个很大的原因在于服务提供方自己本身的固执。比如我们都知道HR软件巨头PeopleSoft有一本巨大的手册，教开发者怎么配置它。这个听起来问题并不大对不对，毕竟是一个复杂的企业级系统嘛。我们都知道 https://wiki.c2.com/?LehmansLaws ，这个也是常见的习以为常的现象了。

我觉得你反复拿那个PeopleSoft的手册来举例，是不对的，因为那个问题是需求自身的复杂度引起的，就算写代码实现，仍然会有这么多参数

但是我们把这个问题换一个主角，如果这个需要提供一本巨大手册的不是PeopleSoft。在某公司，有一个中台部门，提供了IVR语音的服务。这个团队觉得自己部门要产生更大的impact，才方便那啥。所以我们要把IVR语音这个服务变成一个中台，需要提供配置化和插件化的能力。那么我们就需要把客服的菜单，定时呼叫，呼入转接等等应用场景都服务化，然后提供一本配置手册，给业务部门进行复用。这个时候你还觉得这个方案是没问题的吗?

差异化扩展这个提法的出发点就是我有一个不可分割的整体，一个很有用的东西。然后我要一直存在下去，要能更多的证明自己的价值，我是很伟大的存在。“造成这个问题的一个很大的原因在于服务提供方自己本身的固执”。有一些东西，就不应该不停地扩张自己的边界，甚至最终的结果就是这个东西本身应该被肢解掉。但是出于各种经济上和政治上的原因，这种庞然大物仍然在以不停的形式被反复制造出来。

这些庞然大物最新的一个别名叫中台。它们的口号是赋能业务，让业务写更少的代码，让业务跑得更快。但其实质，都是舍不得自己的一亩三分地，需要保持自己一直存在。

实际上以前的方法论都是不断扩大，比如通过插件什么的。但是最外层的逻辑框架肯定是覆盖了问题域的，这导致原先具体的功能逐步被插件实现，整体框架空洞化，最终它自身存在的意义被消解。最后可能没有人知道插件之间的依赖关系到底是什么，他们是如何进行交互的，真正系统中的逻辑路径是什么，所有的知识最后都会迷失

@zc可逆计算 没错。都是非常零散的碎片，一点都看不清楚逻辑路径。但是如我今天立的flag一样，我们这些描述是完全没有意义的。因为这个需要context，需要类似的经验，才能读懂你说的话。要真正描述清楚问题，需要例子，具体的例子

所谓可扩展，说来说去，这些庞然大物可以想到的方案不外乎两个。要么是配置，要么是插件。这里可以举几个例子，说明不同参数化的方案，不同的写插件的方案。先不陷入都这个细节里，包括“可逆计算”，也是一种实现细节。先按下不表。总之我们知道这个底层依赖一定是会有各种手段提供可扩展性的。

回到前面说的，lowcode不过是以依赖的方式，给你预先做好了一些功能。比如说有如下的依赖关系

那一定是提供可复用服务的东西，在依赖关系的底下，更具体的业务，在依赖关系的上面

这种依赖关系就决定了，一定是被依赖得越多，越难以修改，因为改动会影响到的用户就越多。这个也是基本尝试了，依赖方向决定了稳定性。

直接抛一个结论就是，更具体地业务，更易变地业务，更运营性质地业务，应该实现在依赖关系的上面，而不是下面。也就是面向volatility进行包管理。这个分包方案的开创者就是前几天我分享的 david l.Parnas “On the criteria to be used in decomposing systems into modules”，文章没看懂的，可以去看 D 的翻译版本 https://www.slideshare.net/AndreiAlexandrescu2/dconf-2016-what-parnas72-means-for-d-by-luis-marques

以及 uncle bob 从1994年开始提出的包管理原则，其有一个非常被误解的模式，叫 Single Responsibility Principle https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html

这篇文章的正文把其内涵写得很清楚了。但是大家读文章都只读标题的。所以看完了 Single Responsibility 就开始自己意会了。这道题我会，Single 就是要只有一个嘛，那我数数我的class上有几个method，越多就是越不single嘛

responsibility我也会，就是功能点嘛。我实现了一个pm的功能点就是一个responsibility，实现了两个pm的功能点就是两个responsibility。这两个理解都不是其原本的本意

SRP 的本意就是让你别每来一个需求，就往现有的module/package里加，往现有的class和object上硬改，就这么简单

也就是在一个依赖关系上，SRP的意思是，优先往上叠一层，而不是修改底层的依赖

但是基本上没有人会这么做需求，每个需求默认就是在原有的git仓库里开始改，没有人会想着这个需求是不是应该单独拿出去实现更好一些呢

但是做需求这个东西就像硬抗伤害一样，会有内伤的。需求做得越多，一个git仓库，就会被改得越凄惨

当然这里，我们仍然需要给一些具体例子

然后往上叠呢，就出现了下面这个更恐怖的模式

以业务收口的名义，我们有后端同学喜欢的“业务编排API”，也有前端同学喜欢的“BFF”

你不是说要往上叠嘛，那我就统一套一层，所有的业务逻辑都可以写到这里了

所有的业务逻辑，你就改这里好了

但是问题仍然是，越上层的依赖应该是越不稳定的。你这个API层，需要承受所有业务线所有也许业务可能的组合。永远做不完的需求，永远要等的排期。

我认为出现红色这部分，原因就是因为现有的一些研发模式引起的。在我的看法中，红框和下面那条业务，是一体化的，业务编排API和BFF，就是应该融入下面所说的业务中，业务只有那一层编排。没有这么多层。

所以我们重新看一下上面这个依赖关系，最顶上的API肯定是不能做所有的需求的。把需求都放在订单系统，也是有问题的。最合适的地方，应该是中间这一层。

放在下层的问题在于1、稳定性问题，越底层的模块要更稳定。包括4个9意义上的稳定。2、以及Common Reuse Principle，要复用就全部。否则就会引入额外的理解负担，复用了大量用不到的东西

淘宝的订单交易链路一些小业务开始不敢用，就是怕把这个交易链路搞挂来。我这么一个小业务赔不起的。

放在上层的问题在于1、这里可以做一切的业务，意味着大家都想来改你。越上层就越不稳定。2、第二个问题就是你拿不准该往哪里写。我一个需求是往API里写，还是往更具体的业务模块里写呢。大家定位都是写业务的，那咋办呢。就变成了排排坐，分活干的模式。雨露均沾

所以排除了这两种反模式，就是大家喜闻乐见的 vscode 插件模式了。

从依赖关系上来看，似乎是一样的。但是 vscode 插件模式下，有几个显著不同的特征

1、没有最顶上那层可编程的编排。编排就是编程，编程就是啥都能干，最后就是一团糟

2、插件之间没有互相的扩展关系。最多有一些启动顺序上的依赖，以及由平台转发的command触发。基本上都只依赖于这个底座

这种模式下的扩展性，“受力比较均匀”，所有的插件都直接面向用户，甚至直接提供了UI，这样大部分的复杂度都消化到自己内部了

所以回到最初始的我那个论点，就是扩展性是这些平台刷自己存在感造出来的问题

一个比较直观的感受那就是，如果你能把功能分解为在UI上进行集成，那么这个分解往往可以让彼此之间沟通少一点，排期可以更并行一些

但如果你有一层在那挡着，以收口端，收口UI，收口API的名义放在那里，那么势必就会造成大家都要去改你

所以可扩展性不在于维护那“一个东西”的存在感，而是应该把
1、按 volatility 进行分包，把不稳定的东西提到依赖关系的上层来
2、不同的变化方向应该有不同的包，是多个包直接对外，而不是往一个API/BFF层里塞
3、直觉上来说包之间的集成关系有优劣之分，UI集成貌似就显著地更少出集成的问题。
4、最上层是应该有一个装配，把插件都组合起来。但这一层务必不能可编程。

以上就是我的主要论点。然后就是到具体的“技术”层面的问题。什么叫“更少地出现集成的问题”

但是这个答案并不是提出lowcode的资本家们希望的结果，因为它不能回答业务怎么提效的问题。你不能提供一个大而全的东西给我立马复用，一分钟上线，我拿什么去吹呢?

很遗憾的是，这种大而全的玩意，真的不work，多少年了，仍然是不work的

我对这里面的部分细节有不同观点：

1. 所谓复用，复用的是什么？某个领域的业务架构，最重要的是过往的经验，比如你设计一个CRM，就知道要把用户、订户、客户、订单这四个模型居中作为核心，然后，所谓可扩展，是非关键模型的添加、关键模型的部分字段的调整。复用的东西就是这个潜在的已经提炼好的领域模型。提效的就是针对它们再次抽象的过程，至于其他模型的设计，好坏并没有那么重要。所以，提效环节在这里，体现为：关键模型的无需再次重新提炼，次要模型的一些典型示例。

2. 在我看来，BFF这类概念的仍然流行，是因为现在的前端还是手写的，裁缝式的，而没有抽象。你刚才提到的上层接口只允许组合，不允许编程，这个我认同。上层接口是广义前端的消费对象，最好的方式是把对接口的需求描述在前端，这样就要求接口层是一个泛化的东西，这也就是类似 GraphQL 这种东西在这里体现的意义

以复用为出发点就遇到我复用得多了，扩展就难。我复用得少了，似乎就没啥依赖你的必要。这个两难的境地

你只复用一个基础的表结构，似乎是不大可能出啥问题的。收益也比较小。所以一般会复用一些业务流程，以及支持这些流程的界面。然后需求变更就排山倒海的压过来了

业务流程和界面都算是一种编排，编排有什么可复用的？直接就改啊

如果不是复用这个底座，不是以复用为目标，去复用这个xxx平台，那这个平台提供的意义是什么呢

平台的意义：

1. 更多的管控能力，需求和实现的一体化表达

2. 最基础的两头资源是可以被无感化的

两头是指：

- 存储
- 交互

有两点意义：1、平台的意义不在于平台直接提供了什么直接可复用提效的东西。而是制定标准，使得互联互通成为可能。其他插件的存在，是你愿意给这个平台写新插件的原因。复用的是其他的插件

2、一个人的精力是有限的，需要缩少知识边界。说白了就是不用把代码都看了就敢开始改代码

平台可以缩小你的知识边界，可以忽略掉上层的易变的业务部分

我首先要考虑的问题，首先是依赖关系

然后确定好这个依赖关系结构之后，要选择如何把模块分出来（所谓modularization），又如何把模块粘贴回去（所谓composition）。“可逆计算”，就是一种很有用的 composition 的方式

1、确定依赖关系结构 2、选择模块之间的边界，以及选择这些边界的原因 3、具体的实现出来编译器和运行时

回到我之前说的这三个步骤，大部分的情况下，第一步就走错了。要么是妄图把一个最底层的模块做得非常有业务价值，非常有impact。要么就是在最上层搞了一坨收口的东西。

而且更糟糕的是微服务的引入，使得大家都鄙视用lib的方式进行组合。自己手里没有一个独立的进程，睡觉就不踏实。微服务很难做到端到端的业务，反而是微前端更有价值。另外一个就是微服务本身是支持循环依赖的，而稍微有点尝试的package manager，都禁止出现lib之间的循环依赖

连lib的组合都被鄙视，就更不要说@zc可逆计算 你的这种基于文本修改的静态lib的组合方式了，被主流技术社区所不容

然后第2个问题就是，我们知道需要用一堆模块来接业务，而不是尝试拿一个平台去参数化搞出来所有的业务组合可能。那么问题就是，你咋知道模块应该怎么切呢?模块之间一堆链式调用，不是一样瞎菜了么。

所以问题在于 modularization 是有无穷种分法的，你可以在业务上选择按流程阶段分，按业务汇报线分等。实现技术上可以是用进程隔离，用动态lib，也可以用可逆计算。谁都无法说服谁

你看lowcode有啥特殊的呢，不又回到了软件工程的另外一个经典难题上来了么，如何说服其他人我的modularization的方式，手法，力度，姿势是最好的

写一个model定义，生成几个CRUD界面，不解决任何实质性问题。难题还在那，难题一点都没解决